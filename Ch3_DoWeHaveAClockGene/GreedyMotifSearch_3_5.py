__author__ = 'ilap'

from collections import Counter
import numpy as np

def consensusMatrix (motifs):
    result = ""

    col_len = len (motifs)
    row_len = len (motifs[0])

    matrix = []
    for row in motifs:
        matrix.append([str (x) for x in row])

    nmatrix = np.array(matrix)

    for col_idx in range (0, row_len):
        col = nmatrix[:, col_idx]
        counter = Counter (col.tolist())
        (N, maxv) = counter.most_common()[0]
        #print "MAX", N

        result += N

    return result

def countMatrix (motifs):
    col_len = len (motifs)
    row_len = len (motifs[0])

    count_matrix = [[0]*row_len]*4
    matrix = []
    for row in motifs:
        matrix.append([str (x) for x in row])

    nmatrix = np.array(matrix)
    cmatrix = np.array(count_matrix)

    for col_idx in range(0, row_len):
        col = nmatrix[:, col_idx]
        #print "COL", col
        counter = Counter (col.tolist())
        cmatrix[0, col_idx] = counter['A']
        cmatrix[1, col_idx] = counter['C']
        cmatrix[2, col_idx] = counter['G']
        cmatrix[3, col_idx] = counter['T']


    return cmatrix

def profileMatrix (matrix):
    return matrix/10.

def laplaceProfileMatrix (matrix):
    val = sum (matrix[:,0])+4
    return (matrix+1.0)/val


def scoreMatrix (motifs):
    result = 0

    col_len = len (motifs)
    row_len = len (motifs[0])

    matrix = []
    for row in motifs:
        matrix.append([str (x) for x in row])

    nmatrix = np.array(matrix)

    for col_idx in range (0, row_len):
        col = nmatrix[:, col_idx]
        counter = Counter (col.tolist())
        (N, maxv) = counter.most_common()[0]
        #print "MAX", maxv, col_len

        result += col_len - maxv


    return result

def probability (kmer, profile_matrix):
    N = ["A", "C", "G", "T"]

    klen = len (kmer)


    idx = N.index(kmer[0])
    result = profile_matrix[idx,0]

    for i in range (1, klen):
        idx =  N.index(kmer[i])
        val = profile_matrix[idx,i]

        #if val != 0.0:
        result *= val

    return result


'''
Profile-most Probable k-mer Problem: Find a Profile-most probable k-mer in a string.
     Input: A string Text, an integer k, and a 4 x k matrix Profile.
     Output: A Profile-most probable k-mer in Text.

'''
def findMostProbableKmer (kmer, k, profile_matrix):
    result = ""

    klen = len (kmer)

    max = -1.
    for i in range (0, klen - k + 1):
        skmer = kmer[i:i+k]
        pr = probability(skmer, profile_matrix)
        if pr > max:
            max = pr
            result = skmer
        #print skmer, pr

    #print kmer
    return result

'''
    Input: Integers k and t, followed by a collection of strings Dna.
    Output: A collection of strings BestMotifs resulting from applying GREEDYMOTIFSEARCH(Dna,k,t).
    If at any step you find more than one Profile-most probable k-mer in a given string, use the
    one occurring first.
'''
def greedyMotifSearch (motifs, k, t):

    result = []

    best_motifs = [str (x[0:k]) for x in motifs]
    #print "BEST:", best_motifs
    ### profile_matrix = profileMatrix(countMatrix(best_motifs))
    ###print "PM:", profile_matrix

    dna = motifs[0]
    dlen = len (dna)

    for i in range (0, dlen - k + 1):
        kmer = dna[i:i+k]

        tmotifs = [kmer]
        #print "KMER", kmer
        for j in range (1, t):
            # REPLACED by 3.6 profile_matrix = profileMatrix(countMatrix(tmotifs))
            profile_matrix = laplaceProfileMatrix(countMatrix(tmotifs))
            tmotifs.append (findMostProbableKmer(motifs[j], k, profile_matrix))

        if scoreMatrix(tmotifs) < scoreMatrix(best_motifs):
            best_motifs = tmotifs[:]
        #print kmer


    return best_motifs

##### Main
# @@@ Step2
#T= "TCGGGGGTTTTT CCGGTGACTTAC ACGGGGATTTTC TTGGGGACTTTT AAGGGGACTTCC TTGGGGACTTCC TCGGGGATTCAT TCGGGGATTCCT TAGGGGAACTAC TCGGGTATAACC"

#motifs = T.split(' ')

#consensus =  consensusMatrix (motifs)
#profile = profileMatrix(countMatrix(motifs))

T = "0.4 0.3 0.0 0.1 0.0 0.9 0.2 0.3 0.0 0.4 0.0 0.1 0.1 0.3 1.0 0.1 0.5 0.0 0.3 0.1 0.0 0.4 0.5 0.0"
k = 6
profile = [ np.float32 (x) for x in T.split ()]
profile = np.array (profile)
profile = profile.reshape(4,k)
print probability("GAGCTA", profile)
exit

#print probability("TCGGGGATTTCC", profile)
#print probability("TCGTGGATTTCC", profile)

#@@@ Step 3

#T ="0.229 0.277 0.289 0.265 0.241 0.193 0.253 0.253 0.277 0.241 0.265 0.277 \
#0.301 0.241 0.289 0.181 0.169 0.253 0.265 0.325 0.205 0.217 0.277 0.289 \
#0.241 0.181 0.193 0.289 0.289 0.265 0.241 0.241 0.289 0.229 0.253 0.241 \
#0.229 0.301 0.229 0.265 0.301 0.289 0.241 0.181 0.229 0.313 0.205 0.193"
#k = 12
#profile_matrix = [ np.float32 (x) for x in T.split ()]
#profile_matrix = np.array (profile_matrix)
#profile_matrix = profile_matrix.reshape(4,k)
#print profile_matrix
#profile_matrix

#print findMostProbableKmer("ATCGTTGTTGTTCTCTGAAGGCCTGGGCTCAACCGGGGTTGCACGGCGAACAAACTAGCTCAGCATGGTAGCCGGCGCAATCATCTAACATCATTGGACGGGAGCCGATATCACTGAGATCGATGCGCCAACCTCAAGCTCGCGTCTCCCCATACGAAATTTTGCTCTAACTAGGTGAGTGCGTGAAGTCATGATTGATCCCACCTTTCTGATAAAATTTAGGCTCGTCTCCCCGCACGCGCTTATTCAAGGAACTGACCGCGCATCTCTATGAGCTGAGGTAGTCGTTCTCAGGGAGGGACTCTAGGCATGGCAAAATTGTTACGCCTTAACACTCGAGTATTTCCGGGAACCGCATTAGCACTAAGGCAATTACACATCTCAACACCACTACACCTGTGCAGGACTACGTTGGGTGACTTATATGTGGCGGCACCCTTTCGGGAGTAAATCTACACGGAACGGTCAATCATTCTGACTAGCATCGAGCATCTCGGATGGGATTCCGGCGAGTGCCATGACATAATCGCGCCCAGCACACCAGTTACCTACCCACGCGGGGTGTCTAGCAGGTAGGACTCAAGAGTCGATCGGGGGATAGGATAAGTGTTAAGTTTTTCTTTCCGTCACAGAAATCGCGGAAATTCTAGGGTTAATCAGGAACCCATATGACCTTTTAATACCAAGTGCATAGGTCTGGCTTTTCGTGCAGGGGATACTGAAAAGTCGGTCGGTCAGGGTCGAGACTATCAGGAGTACACCGGTAGATTGGGTTTGTTTTCCACAGCAGCGACGTCCGTGTTGCAGCATCAGAATTAGCGGAGGCAATGAGGACGGCTAGAACTTGTAGGATGAGCGCTACGATAATACTAAAGTTGGCACACTCACAAGTCTCAAGGTCTCGCCTTAGGGTGATAGGTCCCCTTGGTGATATTGCTGTATGTATTGCAATATTCTCTCGGGGATTTTTCGGCTTTCGACCTATCGCAATGGGCACCGC", k, profile_matrix)


T="GTAACTGAGCAGCAATTGATTTTTACAGCGTCTCTGATTTGTACGCAGGCCGTAAACTATGTATCCAGGTAGAGTTATCCTCGTAAGCCCATTACGGATTGTGGACCAATATGCGATTCCGCCGGTTGGACCAGGTAGCTTCGAGCGTTGATCTAG \
GCCGGTTCGGTCCCCGAATTGACAATATGTTGAAAGTCCGTCCAGCGCGGTTAAATATGAAATCTAAAAGGCCGCAGATAAGGTTAACGCTCTTACAAGTCACGGTGGATCGTATGTGGAGTTTTCATCTACAGTCGGATCAATGCGTCTTACATG \
GTTTATTTCGACACGGGCTGAAAGATGTCAAAGGCAACGGGAACGCGAGAATGCATCGGGGGAAACACAACGTTAGAGTATTATATGTTGAGTGTGTCCCACTGTGAGGGCATCTATTGTTTGGCTTTCGGACCAACGACTTAGGCCGGTTCGATC \
GGCGGTTCGACCCCTACCTGGAGGCACTCATGATATAGCTAATAATTGGCTTAATTTTTCGGACGCATACAGAGGTAGTATGAAGTTCCACTATTACTGGAGTGTTGGCAAATGTGGCCATCAGCATTAGTCCATTGTTTCAAATTTCTAATAGTA \
CCTGTCCTTATTAAACCCGACGTAGATCCCATGTAGAAGTATACCAAACGTTATATTGACGCGGTGGATTGGATGACTGGGCCTAAACCCATCCTCCTTACAGAGCACTTCATACCCATCAGTACGAGACGTGGCGGTTGGCACTTGCCTCGGGTC \
TGGAGCACATCCCAGGTGGGGGACAGGCGGGCTACAAGGGTACTCGTAGCAGCGAAACTCCCATACGTAAGTCCGCGCCTAAAGCCTCGTATGCACTGGCTGTTGCAGGACGGTTGGCGCAGTACGATTTCGGGTTGACCAGCTCGTATGAAGTAG \
GGTGGTGGTAACTCCATACGACCGTCGGAAGACATCTGTGCGTTCCGTACTACATAAGGCAGGAAGTATTTTGGGCGATCGGGGGGCGGATGTGGCGCCGGTTTGGCCTAAAACTTTACCTTTACCGTCAGCTTGACCGTTCATCGAGGATTCCGC \
CACTGGCGATGAAAGCATGGTACCACGGTCAAGGAAGTAGGACAGTCTTCTGGTAGATCTCACACCGACACAGACGGTTCGATCCAGTAATGTGAACGAGTTCGCCTTTCCCAAAGACGATTTTAGACCCCGTGAGGGGCTCGACCCACTTTTAAC \
CCAGGGTGTGGATGTGAACCGTGAACCTCCGCAACTCTGCAAGTAAAACTCCATTTAGCTTCGAATTCACCTCCGATTTCAAAAATAACCGCGGTTAAGCATATTATTGCCGGTTTGTTCCTAGCTATACATACCGAACCGCCGTATTCTTCGTGT \
GTCGGTTGGCCCTGGATCCACATTCGCCTTTGGGGCATCAAAATGCAAGACCCTTATCGTCCAAAGTGGCGAGATAGCTCCCACGCAGTATTGTGGCGGACGTTACTCTGCCAATGGGTATGGAGGTGCGCCGACCTTACAAACTCGTATATATTG \
AGAGGACAGTTTGCCGGTTCGCGCTCTTGGTCGGGTCCCGCCAGGTTGGTGACCTTAGGTGTTTACGGAGGAGTGGACAACAACACGGTCTGAGTTCGGAGAATTACCCCTATCACTCTCATTGATTCGCTCAGAATTAGTGACTCGTAAAAACAC \
TGGGTGAAGAGCTTGCAAGACTTGCATTTATTAATAGCCGGTTGGAGCAACGCTAGGGTAACAAACACCCTCGAGTTACGTTACATATGCTACATGCGCTCCTCCTGGATGCGGATGGTCGCTGCCACTATTCCGTCGCGTGTCGCAAACTCCATA \
TCACATAATTTCCAGTTTCATAACTTTGACTACTTTACTTAGTGTACTCGGGATGTGCAAGGGAAAGCGGCACACAGGGTGTCAGCGCGAGCAAATGACGGTTGGGTCTCTAGGCCGCTATCCGCTAATTAGCTTCCCACAGACATTTTCAAGTGC \
ATGCGTTGAGTGCACCAATGTCATCCAACGGGCGTGGCCGGTTAGGTCGGGCAACACACATAAGGGCAACGTGTATATGCTCAGCTCAGTGGGTAACCTCGAAGAATGGTTTTTCTAATTCGAAGATATTGAGCCAATTGACTACCGCTCAGTACT \
TCTAGGTTTATAGTGCCGTACTGGGGACATTGCTTTAACTGAGCATCTACTTAGATCACTGGCATTGGCTTTCCAAGGTAGTTGAATTTTCATACCGACGGTTCGCGCGAAATCGATCGAGTAGACTTTAGGTCAAGGTCAGAATCCCCGAAAATA \
ACCGTTACCGGTAACGGATTGCGCTCGTAGGGCCCAGGCGGTTCGCGCCATGACCGGTCGCTACCTTTCAAACGGACCCCTAAGTTCGACGAGCGACAGTCTGATAGACATGGCCGACGTAGATGATGAAGAAACAGGGATGCCAGCGAATTCTCA \
CGTATTGCCCCGTTCATGTAATGGTTCTACGAGTCGCACATCGGAGCCGGCGGTTGGGTCTCTCAAGTACAGTCTTATGCGCACTATACTTAAATTTCAAGGTGTGCTCCCGGGGAGGATTGGGGGTGTCGGCGGCTCGACCACCCTCGTTACGTC \
CGACAACCGGGGCCCATAAGGTAGAATAAATTCTTATGTAGTGCTGTTACCCAATCGCCTTACTCTTACTTGGGCGGTTAGTGCCCGTGCTTGCAAATAACTGCCCTTGACTTCATCGCGGCCAACATCCAGCTCGTACGCATACGCAGACTCCCA \
GTTGCTATCACCGCGATATCTAGCGGATACGATGTCATGGTCCCTCCCTCTGGATAGAGAGGAGCAACGGTATTGTCGCATGAGGCTCATTGTGGACGCCCTTACACAATTTCAGGCTGCGGCGGTTGGCCCCCATTGATGAAGCATACTCTGCTT \
ACCATTGTACGTGATTCGTTAGCACAATCAAACGGGTAACCTGTACTCCGTGGGGATGCTCGTCAACACATGACGCTGAATGTGGCCGGTTTGGGCTGGACTTCTGACGCTACCTTTGGTCTTGGCTACACAAGCAACAAATATTGCGTATCTTTT \
ACAATCGAAACTTAAAACTCACACATATCTTTTACCTAAGTTCGTGAAAACGAGAAATACGGATAGCGTAGGGAAGAATATCAAGACGGTTTGTTCTTTCAACCTGCGCGATTGTTGTATACCACAGGAACCCCATACCGGGCAAAGTACGACTTC \
TGAGGCAGGAAAAGTGCTTGGCTTGACGGTTTGAACGTTAGAAAGATTATGATGGGCAAGATGCAGGTCCACTGTAGCGGAGATAAAATGCCCGGACCTCTGTGCATATGTCGCGACTTGGGGGCCACCACTTTTCGAAGCCGGGCGGGGCGACCC \
ATCTTAAGCACAGTCTGCCTCTGTCGCTGATACTGGCTATCGCGGTGCTGTGAGGGCGTTGGTTTGTAGGCGGGACGTCTGTGCGCCTTTACGCTGGCAACGCGAAGTGACGGTTAGGACGCAGTTCGACGCTTGCTATCCGTATGAACGCGACTG \
GTCAAGACCAGTCCCGAGGGGCCAATTGTCACCGGCCAAGATAGCCCGGGCGGTTGGCGCTCGCATCTTTGTGCGATCACTTAGAGACCCTTTAAGTCTCCAGCCTTCTAACATAACGTACTTTGAACCATTCACCCCAACCTAGCAACCTCTGTG \
GCCGGTTAGGGCTTGCCTCATCTAATGCTACAAACCTCAGTTGTCCTACTTTTAATACCCCTCGGGGAGACGCTGGTTGGTCGGGGGGTCAGTGAATCGAAGAGTCCGGAAGTACGGGCCTAGCGGAAGTTTGTACGGGATGCCACGTATGCCCAC\
"
k = 12
t = 25

'''T = "GGCGTTCAGGCA \
AAGAATCAGTCA \
CAAGGAGTTCGC \
CACGTCAATCAC \
CAATAATATTCG"
k = 3
t = 5'''
motifs = T.split()

## print motifs
print ' '.join (greedyMotifSearch(motifs, k, t))

## USE laplace instead of print laplaceProfileMatrix(countMatrix(["ACCT", "ATGT", "ACGG", "ACGA"]))
